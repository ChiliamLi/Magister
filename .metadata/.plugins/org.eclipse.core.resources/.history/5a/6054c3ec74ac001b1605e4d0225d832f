package hw5;

import java.util.HashMap;

public class BipartiteMatching {
 
    //after running FF, we will return each pair into a data structure
    //What we want from this implementation is to output 
    //a residual graph with all the flows = edge weights
    public static StudentTutorGraph doFF(StudentTutorGraph g) {
        
        int u, v;
        int s = 0;
        int t = g.getSize()-1;
        
        // Create a residual graph and fill the residual
        // graph with given capacities in the original graph
        // as residual capacities in residual graph
        
        // Residual graph where rGraph[i][j] indicates
        // residual capacity of edge from i to j (if there
        // is an edge. If rGraph[i][j] is 0, then there is
        // not)
        StudentTutorGraph rGraph = new StudentTutorGraph(g.numStudents, g.numTutors, g.numCourses);
        
        // create and set residual graph to be equal to the equal to the original graph        
        for (int i = 0; i < g.getSize(); i++) {
            HashMap<Integer, Integer> hm = g.g.get(i);
            for (int j : hm.keySet()) {
                rGraph.addEdge(i, j, hm.get(j));
                rGraph.addEdge(j, i, 0);
            }
        }
 
        int max_flow = 0; // There is no flow initially
 
        // Augment the flow while there is path from source
        // to sink
        //CHECK IF IT'S REACHABLE AND MODIFY the parents
        while (BFS.isReachable(rGraph, s, t)) {
            // Find minimum residual capacity of the edhes
            // along the path filled by BFS. Or we can say
            // find the maximum flow through the path found.
            int[] parent = BFS.getPath(rGraph, s, t);
            int path_flow = Integer.MAX_VALUE;
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                path_flow = Math.min(path_flow, rGraph.getWeight(u, v));
//                System.out.println("edge from " + u + " to " + v  + ": " + rGraph.getWeight(u, v));
            }
 
            // update residual capacities of the edges and
            // reverse edges along the path
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                rGraph.setEdge(u, v, rGraph.getWeight(u, v) - path_flow); 
                rGraph.setEdge(v, u, rGraph.getWeight(v, u) - path_flow); 
            }

            // Add path flow to overall flow
            max_flow += path_flow;
        }
 
        System.out.println("Max flow: " + max_flow);
        // Return the overall flow
        return rGraph; 
    }
    
    public static void getMatchings(StudentTutorGraph g, StudentTutorGraph rGraph) {
        // subtract final residual graph weights from original weights
        for (Student s : g.students) {
            for (Course course : s.getCourses()) {
                int courseIndex = g.getCourseIndex(course.ordinal());
                int studentIndex = g.getStudentIndex(s.getID());
                g.setEdge(courseIndex, studentIndex, 
                        g.getWeight(courseIndex, studentIndex) - 
                        rGraph.getWeight(courseIndex, studentIndex));
            }
        }
        for (Tutor t : g.tutors) {
            for (Course course : t.getProficientCourses()) {
                int courseIndex = g.getCourseIndex(course.ordinal());
                int tutorIndex = g.getTutorIndex(t.getID()) + 1;
                g.setEdge(tutorIndex, courseIndex, 
                        g.getWeight(tutorIndex, courseIndex) - 
                        rGraph.getWeight(tutorIndex, courseIndex));
            }
        }
        
        // find all matchings
        for (int i = 0; i < g.numTutors; i++) {
            for (int j = i; j < g.numCourses; j++) {
                for (int k = 0; k < g.numStudents; k++) {
                    int tutorIndex = g.getTutorIndex(i) + 1;
                    int courseIndex = g.getCourseIndex(j);
                    int studentIndex = g.getStudentIndex(k);
//                    System.out.println(tutorIndex + " " + courseIndex + " " + studentIndex);
                    if (g.hasEdge(tutorIndex, courseIndex) && 
                            g.getWeight(tutorIndex, courseIndex) > 0 && 
                            g.hasEdge(courseIndex, studentIndex) && 
                            g.getWeight(courseIndex, studentIndex) > 0) {
                        System.out.println("Tutor " + g.getTutor(i) + " teaches student " + 
                            g.getStudent(k) + " in " + Course.values()[j].toString().toLowerCase());
                    }
                }
            }
        }
    }
   
}
