package hw5;
import java.util.*;

public class ClosureProperties {
    
//All graph properties can be found in graph.java

    // Inputs our matched graph, and calculates Homophily 
    /*public float homophily (List<List<String>> matchings) {
        return 0; //TODO
    }*/
    
    //Calculates clustering coefficient for tutors
    public double clusteringCoefficientTutor (List<List<String>> matchings, String name) {
        List<List<String>> filtered = new ArrayList<List<String>>();
        ArrayList<String> neighbors = new ArrayList<String>();
        for (List<String> matching: matchings) {
            if (matching.get(0).equals(name)) {
                filtered.add(matching);
                neighbors.add(matching.get(1));
            }
        }
        double count = 0.0;
        System.out.println(neighbors.toString());
        for (String neighbor: neighbors) {
            for(List<String> matching: matchings) {
                if (matching.get(1).equals(neighbor) && neighbors.contains(matching.get(0))) {
                    count++;
                }
            }
        }
        return count/((neighbors.size() * (neighbors.size()-1))/2);
    }
    
    //Calculates clustering coefficient for students
    public double clusteringCoefficientStudent (List<List<String>> matchings, String name) {
        List<List<String>> filtered = new ArrayList<List<String>>();
        ArrayList<String> neighbors = new ArrayList<String>();
        for (List<String> matching: matchings) {
            if (matching.get(1).equals(name)) {
                filtered.add(matching);
                neighbors.add(matching.get(0));
            }
        }
        double count = 0.0;
        System.out.println(neighbors.toString());
        for (String neighbor: neighbors) {
            for(List<String> matching: matchings) {
                if (matching.get(0).equals(neighbor) && neighbors.contains(matching.get(1))) {
                    count++;
                }
            }
        }
        return count/((neighbors.size() * (neighbors.size()-1))/2);
    }
    //Returns a probable focal closure based on tutor-subject frequency
    public String focalClosure (List<List<String>> matchings, String subject) {
        // initialize a tutor hashmap with key = tutor name and value = # of occurrences
        Map<String, Integer> tutorMap = new HashMap<String, Integer>();
        List<List<String>> filtered = new ArrayList<List<String>>();
        for (List<String> matching: matchings) {
            if (matching.get(2).equals(subject)) {
                filtered.add(matching);
            }
        }
        for (List<String> f: filtered) {
            if (!tutorMap.containsKey(f.get(0))){
                tutorMap.put(f.get(0), 1); // create new entry
            }
            else {
                tutorMap.replace(f.get(0), tutorMap.get(f.get(0)) + 1);
            }
        }
        //System.out.println(tutorMap.toString());
        String maxKey = Collections.max(tutorMap.entrySet(), Map.Entry.comparingByValue()).getKey();
        String maxKey2 = "";
        if (tutorMap.size() > 1) {
            tutorMap.remove(maxKey);
            maxKey2 = Collections.max(tutorMap.entrySet(), Map.Entry.comparingByValue()).getKey();
        }
        return (maxKey + " and " + maxKey2 + " are likely to know each other through focal closure."); 
    }
    //Returns a probable membership closure based on frequency
    public boolean membershipClosure (List<List<String>> matchings, String name) {
        return true; //TODO
    }
    /*//Checks if triadic closure is satisfied
    public boolean triadicClosure (List<List<String>> matchings) {
        return true; //TODO
    }*/
    //Checks to see if our tutor/student graph is a bipartite graph
    public boolean BipartiteMatching (List<List<String>> matchings) {
        return true; //TODO
    }
    
    //Calculates the number of subtrees and finds a numerical representation for how connected
    //our graph is (basically how interconnected our tutor/student group is)
    public boolean DFSConnectedness (List<List<String>> matchings) {
        return true; //TODO
    }
    
}
