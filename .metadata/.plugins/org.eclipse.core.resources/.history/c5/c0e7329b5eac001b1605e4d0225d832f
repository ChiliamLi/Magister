package hw5;

import java.util.HashMap;

public class BipartiteMatching {
 
    //after running FF, we will return each pair into a data structure
    //What we want from this implementation is to output 
    //a residual graph with all the flows = edge weights
    public static StudentTutorGraph findFinalResidualGraph(StudentTutorGraph g, int numStudents, 
            int numTutors, int numCourses) {
        
        int u, v;
        int s = 0;
        int t = g.getSize()-1;
        
        // Create a residual graph and fill the residual
        // graph with given capacities in the original graph
        // as residual capacities in residual graph
        
        // Residual graph where rGraph[i][j] indicates
        // residual capacity of edge from i to j (if there
        // is an edge. If rGraph[i][j] is 0, then there is
        // not)
        StudentTutorGraph rGraph = new StudentTutorGraph(numStudents, numTutors, numCourses);
        
        // create and set residual graph to be equal to the equal to the original graph        
        for (int i = 0; i < g.getSize(); i++) {
            HashMap<Integer, Integer> hm = g.g.get(i);
            for (int j : hm.keySet()) {
                rGraph.addEdge(i, j, hm.get(j));
                rGraph.addEdge(j, i, 0);
            }
        }
        
//        for (u = 0; u < g.getSize(); u++) {
//            for (v = 0; v < g.getSize(); v++) {
//                if (g.hasEdge(u,v)) {
//                   rGraph.addEdge(u, v, g.getWeight(u,v));
//                   rGraph.addEdge(v, u, 0); 
//                }
//            }
//        }
 
        int max_flow = 0; // There is no flow initially
 
        // Augment the flow while there is path from source
        // to sink
        //CHECK IF IT'S REACHABLE AND MODIFY the parents
        while (BFS.doBFS1(rGraph, s, t)) {
            System.out.println(true);
            // Find minimum residual capacity of the edhes
            // along the path filled by BFS. Or we can say
            // find the maximum flow through the path found.
            int[] parent = BFS.doBFS2(rGraph, s, t);
            System.out.println(parent);
            int path_flow = Integer.MAX_VALUE;
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                if (rGraph.hasEdge(u,v)) {
                    path_flow = Math.min(path_flow, 1);
                }
                else {
                    path_flow = Math.min(path_flow, 0);
                }
            }
 
            // update residual capacities of the edges and
            // reverse edges along the path
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                rGraph.addEdge(u,v, rGraph.getWeight(u,v)-path_flow); 
                rGraph.addEdge(u,v, rGraph.getWeight(v,u)-path_flow); 
            }

            // Add path flow to overall flow
            max_flow += path_flow;
        }
 
        System.out.println("Max flow: " + max_flow);
        // Return the overall flow
        return rGraph; 
    }
   
}
